Problem1: 最近点对
=============

开发平台
------------
* 平台: Mac OS X 10.11.2
* 编译器: clang++: Apple LLVM version 7.0.2 (clang-700.1.81)
* C++11

依赖库、工具版本
------------
* Qt=4.8.7
* qmake=2.01a

工程结构
------------

-> ![目录结构](./directory_tree.jpg =200x300) <-

* `algo` 子目录: 基础数据结构定义; 算法; 文件操作工具; 随机生成工具;
* `cmd` 子目录: 命令行接口
* `gui` 子目录: 图形界面接口

构建
------------
在p1目录下运行:

```
make
```

构建成功将生成 `build_gui` 和 `build_cmd` 两个目录, 目录下分别是平台的图形界面和命令行可执行文件.

运行 ``make clean`` 可以清除之前构建产生的文件。

成功测试的构建平台:

* Mac OS X 10.11.2: 构建的程序用于报告中的示例运行; 没有随源码上交
* Ubuntu 14.04.5 LTS: 
    * 构建的命令行程序存放在 `build_cmd/` 
    * 构建的图形界面程序: 对不起助教... 没弄出完全static-linked的可执行文件... 只有动态链接的... 要自己手动把要链接的动态库打包成package设置rpath感觉好麻烦... 所以干脆没有传。如果助教愿意可以在Ubuntu上装一个Qt4/5(都测试过), 然后像上面说的运行 ``make`` 编译一个。

运行
------------
1. 生成1000000个随机点, 并写入``p_1000000.bin``:

    ```
    ./build_cmd/points_gen 1000000 p_1000000.bin
    ```

2. 使用刚刚生成的``p_1000000.bin``文件里的1000000个点作为输入，计算最近点:

    ```
     ./build_cmd/main_cmd p_1000000.bin
    ```

3. 也可以使用``./build_cmd/main_cmd_nsquare``这个O(n^2)算法的入口进行对比。但是这个算法很慢, 并不能跑出上面的1000000个点的问题。

4. 在Mac OS X上, 编译后得到的图形界面可执行程序路径为``./build_gui/debug/main_gui.app/Contents/MacOS/main_gui``, 运行得到:

-> ![gui示意图](./images/gui_pic.jpg =380x300) <-

图形界面程序功能如下:

* 可以在图形界面上点击得到新的点。
* 在右上方的panel中输入随机生成的点数, 并点击`随机生成`可随机生成某个范围内的点。
* 点击右下方的`计算`即开始计算最近点对, (没有实现在副线程的计算, 计算在图形界面线程完成)。计算结束后最近点对将在图中用红色细线连接。
* 如果点太多找不到红色细线连接的点对, 可以通过点击`定位点对`, 将上一次计算的最近点对放到图中心。
* 通过滚动鼠标滑轮放大放小图片。
* `加载文件`和`存储文件`分别从文件中加载点列、将当前点列存进文件。
* `清空画布`清空所有点。

下图是随便添加了9个点后, 点击`计算`和`定位点对`后的效果示意图:

-> ![定位点对示意](./images/gui_pic3.jpg =380x300) <-

分析
------------
用这种分治算法求解最近点对问题的复杂度的递推式为:
$$T(n) = 2T(n/2) + O(n)$$
由主定理可以得复杂度为
$$O(nlg(n))$$

使用``cmd/test.sh``脚本对该算法和简单的O(n^2)的算法对同一组随机生成的点列(10k ~ 100k)进行实验, 结果如下图所示:

-> ![时间对比](./images/time_compare.jpg =400x320) <-

绘出时间对比图如下:

-> ![时间对比](./images/diagram_compare.jpg =600x400) <-

可以看出朴素的O(n^2)算法的时间随着N确实以平方规律增长(由于O(n^2)算法已经太慢了，所以没有继续做更多点的对比实验了)。相比其来说, 分治算法运行消耗的时间增长很慢, 其能在几秒内完成1000000个点的最近点对计算。单独画出分治算法更多点(从100k ~ 1000k)的测试数据如下:

-> ![时间对比](./images/daq_time.jpg =600x400) <-

可以看到由于lg(n)函数在这个测试区间的增幅很小, 分治法运行时间随着n在一个很短的n的跨度内甚至基本是线性增长。在大跨度内为O(nlg(n))。